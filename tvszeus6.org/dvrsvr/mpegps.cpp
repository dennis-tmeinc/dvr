#include <stdio.h>
#include <string.h>
#include "mpegps.h"
#include "bits.h"
#include "crypt.h"
#include "osdhdr.h"


#define PES_PROGRAM_STREAM_MAP          0xbc
#define PES_PRIVATE_STREAM_1            0xbd
#define PES_PADDING                     0xbe
#define PES_PRIVATE_STREAM_2            0xbf
#define PES_ECM                         0xb0
#define PES_EMM                         0xb1
#define PES_PROGRAM_STREAM_DIRECTORY    0xff
#define PES_DSMCC_STREAM                0xf2
#define PES_ITU_T_H222_1_TYPE_E_STREAM  0xf8
#define PES_EXTENDED_STREAM_ID          0xfd

#define PES_PAYLOAD_SIZE_MAX 65500

int ps_pkt_size( uint8_t *p, int i_peek );

static psblock_t *psblock_New(psblock_t *pBlock, uint8_t *p_start, int i_size)
{
  psblock_t *p_block = pBlock;
  p_block->i_pts = 0;
  p_block->i_dts = 0;
  p_block->i_buffer = p_block->i_buf = i_size;
  p_block->p_buffer = p_block->p_buf = p_start;
  p_block->i_flags = 0;

  return p_block;
}

struct frameperiod {
	uint32_t numerator, denominator;
};

struct resolution {
	uint32_t width, height;
};

int decode_rbsp_trailing(const uint8_t *src){
    int v= *src;
    int r;

    for(r=1; r<9; r++){
        if(v&1) return r;
        v>>=1;
    }
    return 0;
}
#if 0
int decode_seq_parameter_set(SPS *sps, GetBitContext *gb){
    int profile_idc, level_idc;
    unsigned int sps_id;
    int i;

    profile_idc= get_bits(gb, 8);
    get_bits1(gb);   //constraint_set0_flag
    get_bits1(gb);   //constraint_set1_flag
    get_bits1(gb);   //constraint_set2_flag
    get_bits1(gb);   //constraint_set3_flag
    get_bits(gb, 4); // reserved
    level_idc= get_bits(gb, 8);
    sps_id= get_ue_golomb_31(gb);

    if(sps_id >= MAX_SPS_COUNT) {
        TRACE(_T("sps_id (%d) out of range\n"), sps_id);
        return -1;
    }

	sps->time_offset_length = 24;
    sps->profile_idc= profile_idc;
    sps->level_idc= level_idc;

    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));
    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));
    sps->scaling_matrix_present = 0;

    if(sps->profile_idc >= 100){ //high profile
        sps->chroma_format_idc= get_ue_golomb_31(gb);
        if(sps->chroma_format_idc == 3)
            sps->residual_color_transform_flag = get_bits1(gb);
        sps->bit_depth_luma   = get_ue_golomb(gb) + 8;
        sps->bit_depth_chroma = get_ue_golomb(gb) + 8;
        sps->transform_bypass = get_bits1(gb);
        //decode_scaling_matrices(h, sps, NULL, 1, sps->scaling_matrix4, sps->scaling_matrix8);
    }else{
        sps->chroma_format_idc= 1;
        sps->bit_depth_luma   = 8;
        sps->bit_depth_chroma = 8;
    }

    sps->log2_max_frame_num= get_ue_golomb(gb) + 4;
    sps->poc_type= get_ue_golomb_31(gb);

    if(sps->poc_type == 0){ //FIXME #define
        sps->log2_max_poc_lsb= get_ue_golomb(gb) + 4;
    } else if(sps->poc_type == 1){//FIXME #define
        sps->delta_pic_order_always_zero_flag= get_bits1(gb);
        sps->offset_for_non_ref_pic= get_se_golomb(gb);
        sps->offset_for_top_to_bottom_field= get_se_golomb(gb);
        sps->poc_cycle_length                = get_ue_golomb(gb);

        for(i=0; i<sps->poc_cycle_length; i++)
            sps->offset_for_ref_frame[i]= get_se_golomb(gb);
    }else if(sps->poc_type != 2){
        goto fail;
    }

    sps->ref_frame_count= get_ue_golomb_31(gb);
    if(sps->ref_frame_count > MAX_PICTURE_COUNT-2 || sps->ref_frame_count >= 32U){
        goto fail;
    }
    sps->gaps_in_frame_num_allowed_flag= get_bits1(gb);
    sps->mb_width = get_ue_golomb(gb) + 1;
    sps->mb_height= get_ue_golomb(gb) + 1;

    sps->frame_mbs_only_flag= get_bits1(gb);
    if(!sps->frame_mbs_only_flag)
        sps->mb_aff= get_bits1(gb);
    else
        sps->mb_aff= 0;

    sps->direct_8x8_inference_flag= get_bits1(gb);
    if(!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag){
        TRACE(_T("This stream was generated by a broken encoder, invalid 8x8 inference\n"));
        goto fail;
    }

#ifndef ALLOW_INTERLACE
    if(sps->mb_aff)
        TRACE(_T("MBAFF support not included; enable it at compile-time.\n"));
#endif
    sps->crop= get_bits1(gb);
    if(sps->crop){
        sps->crop_left  = get_ue_golomb(gb);
        sps->crop_right = get_ue_golomb(gb);
        sps->crop_top   = get_ue_golomb(gb);
        sps->crop_bottom= get_ue_golomb(gb);
        if(sps->crop_left || sps->crop_top){
            TRACE(_T("insane cropping not completely supported, this could look slightly wrong ...\n"));
        }
        if(sps->crop_right >= 8 || sps->crop_bottom >= (8>> !sps->frame_mbs_only_flag)){
            TRACE(_T("brainfart cropping not supported, this could look slightly wrong ...\n"));
        }
    }else{
        sps->crop_left  =
        sps->crop_right =
        sps->crop_top   =
        sps->crop_bottom= 0;
    }

    sps->vui_parameters_present_flag= get_bits1(gb);
    if( sps->vui_parameters_present_flag )
        if (decode_vui_parameters(sps, gb) < 0)
            goto fail;

    if(!sps->sar.den)
        sps->sar.den= 1;
#ifdef _DEBUG
		TCHAR *charray[] = {_T("Gray"),_T("420"),_T("422"),_T("444")};
    TRACE(_T("sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%d/%d/%d/%d %s %s %d/%d\n"),
               sps_id, sps->profile_idc, sps->level_idc,
               sps->poc_type,
               sps->ref_frame_count,
               sps->mb_width, sps->mb_height,
               sps->frame_mbs_only_flag ? _T("FRM") : (sps->mb_aff ? _T("MB-AFF") : _T("PIC-AFF")),
               sps->direct_8x8_inference_flag ? _T("8B8") : _T(""),
               sps->crop_left, sps->crop_right,
               sps->crop_top, sps->crop_bottom,
               sps->vui_parameters_present_flag ? _T("VUI") : _T(""),
               charray[sps->chroma_format_idc],
               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,
               sps->timing_info_present_flag ? sps->time_scale : 0
               );
#endif
    return 0;
fail:
    return -1;
}

int parse_sps(uint8_t * sps_data, int sps_length, struct frameperiod *fp, struct resolution *res)
{
	GetBitContext gb;
	int bit_length;
    SPS sps;

	while (sps_data[sps_length - 1] == 0 && sps_length > 1)
		sps_length--;

	bit_length = !sps_length ? 0 : (8 * sps_length - decode_rbsp_trailing(sps_data + sps_length - 1));

	init_get_bits(&gb, sps_data, bit_length);

	if (!decode_seq_parameter_set(&sps, &gb)) {
		fp->numerator = sps.num_units_in_tick * 2;
		fp->denominator = sps.time_scale;
		res->width = sps.mb_width * 16;
		res->height = sps.mb_height * 16;
	}

	return 0;
}
#endif
/* Init a set of track */
static void ps_track_init( ps_track_t tk[PS_TK_COUNT] )
{
	int i;
	for( i = 0; i < PS_TK_COUNT; i++ )
	{
		tk[i].b_seen = false;
		tk[i].i_skip = 0;
		tk[i].i_id   = 0;
		tk[i].i_first_pts = -1;
		tk[i].i_last_pts = -1;
	}
}

/* parse a PACK PES */
int ps_pkt_parse_pack( BLOCK_T *p_pkt, int64_t *pi_scr, int *pi_mux_rate )
{
	uint8_t *p = p_pkt->p_buffer;
	if( p_pkt->i_buffer >= 14 && (p[4] >> 6) == 0x01 )
	{
		*pi_scr =((((int64_t)p[4]&0x38) << 27 )|
			(((int64_t)p[4]&0x03) << 28 )|
			((int64_t)p[5] << 20 )|
			(((int64_t)p[6]&0xf8) << 12 )|
			(((int64_t)p[6]&0x03) << 13 )|
			((int64_t)p[7] << 5 )|
			((int64_t)p[8] >> 3 )) * 100 / 9;

		*pi_mux_rate = ( p[10] << 14 )|( p[11] << 6 )|( p[12] >> 2);
	}
	else if( p_pkt->i_buffer >= 12 && (p[4] >> 4) == 0x02 )
	{
		*pi_scr =((((int64_t)p[4]&0x0e) << 29 )|
			((int64_t)p[5] << 22 )|
			(((int64_t)p[6]&0xfe) << 14 )|
			((int64_t)p[7] <<  7 )|
			((int64_t)p[8] >> 1 )) * 100 / 9;

		*pi_mux_rate = ( ( p[9]&0x7f )<< 15 )|( p[10] << 7 )|( p[11] >> 1);
	}
	else
	{
		return EGENERIC;
	}
	return SUCCESS;
}

/* Parse a SYSTEM PES */
int ps_pkt_parse_system( BLOCK_T *p_pkt, ps_track_t tk[PS_TK_COUNT] )
{
	uint8_t *p = &p_pkt->p_buffer[6 + 3 + 1 + 1 + 1];

	/* System header is not useable if it references private streams (0xBD)
	* or 'all audio streams' (0xB8) or 'all video streams' (0xB9) */
	while( p < &p_pkt->p_buffer[p_pkt->i_buffer] )
	{
		int i_id = p[0];

		if( p[0] >= 0xBC || p[0] == 0xB8 || p[0] == 0xB9 ) p += 2;
		p++;

		if( i_id >= 0xc0 )
		{
			int i_tk = PS_ID_TO_TK( i_id );

			if( !tk[i_tk].b_seen )
			{
				//if( !ps_track_fill( &tk[i_tk], p_psm, i_id ) )
				//{
				tk[i_tk].b_seen = true;
				//}
			}
		}
	}
	return SUCCESS;
}

uint8_t * find_NAL_start(uint8_t * pbyte, int len, int nal_unit_type)
{
	int i;
	uint8_t * p = NULL;

	for (i = 0; i < len - 5; i++) {
		if ((pbyte[i+0] == 0x00) && 
			(pbyte[i+1] == 0x00) && 
			(pbyte[i+2] == 0x00) && 
			(pbyte[i+3] == 0x01) && 
			((pbyte[i+4] & 0x1f) == nal_unit_type)) {
				p = pbyte + i;
				break;
		}
	}

	return p;
}

/* Parse a PES (and skip i_skip_extra in the payload) */
int ps_pkt_parse_pes( BLOCK_T *p_pes, int i_skip_extra, int *p_header_len )
{
	uint8_t header[30];
	int     i_skip  = 0;

	memcpy( header, p_pes->p_buffer, min1( p_pes->i_buffer, 30 ) );

	switch( header[3] )
	{
	case 0xBC:  /* Program stream map */
	case 0xBE:  /* Padding */
	case 0xBF:  /* Private stream 2 */
	case 0xB0:  /* ECM */
	case 0xB1:  /* EMM */
	case 0xFF:  /* Program stream directory */
	case 0xF2:  /* DSMCC stream */
	case 0xF8:  /* ITU-T H.222.1 type E stream */
		i_skip = 6;
		break;

	default:
		if( ( header[6]&0xC0 ) == 0x80 )
		{
			/* mpeg2 PES */
			i_skip = header[8] + 9;

			if( header[7]&0x80 )    /* has pts */
			{
				p_pes->i_pts = ((mtime_t)(header[ 9]&0x0e ) << 29)|
					(mtime_t)(header[10] << 22)|
					((mtime_t)(header[11]&0xfe) << 14)|
					(mtime_t)(header[12] << 7)|
					(mtime_t)(header[13] >> 1);

				if( header[7]&0x40 )    /* has dts */
				{
					p_pes->i_dts = ((mtime_t)(header[14]&0x0e ) << 29)|
						(mtime_t)(header[15] << 22)|
						((mtime_t)(header[16]&0xfe) << 14)|
						(mtime_t)(header[17] << 7)|
						(mtime_t)(header[18] >> 1);
				}
			}
		}
		else
		{
			i_skip = 6;
			while( i_skip < 23 && header[i_skip] == 0xff )
			{
				i_skip++;
			}
			if( i_skip == 23 )
			{
				return EGENERIC;
			}
			if( ( header[i_skip] & 0xC0 ) == 0x40 )
			{
				i_skip += 2;
			}

			if(  header[i_skip]&0x20 )
			{
				p_pes->i_pts = ((mtime_t)(header[i_skip]&0x0e ) << 29)|
					(mtime_t)(header[i_skip+1] << 22)|
					((mtime_t)(header[i_skip+2]&0xfe) << 14)|
					(mtime_t)(header[i_skip+3] << 7)|
					(mtime_t)(header[i_skip+4] >> 1);

				if( header[i_skip]&0x10 )    /* has dts */
				{
					p_pes->i_dts = ((mtime_t)(header[i_skip+5]&0x0e ) << 29)|
						(mtime_t)(header[i_skip+6] << 22)|
						((mtime_t)(header[i_skip+7]&0xfe) << 14)|
						(mtime_t)(header[i_skip+8] << 7)|
						(mtime_t)(header[i_skip+9] >> 1);
					i_skip += 10;
				}
				else
				{
					i_skip += 5;
				}
			}
			else
			{
				i_skip += 1;
			}
		}
	}

	i_skip += i_skip_extra;

	if( p_pes->i_buffer <= i_skip )
	{
		return EGENERIC;
	}

	p_pes->p_buffer += i_skip;
	p_pes->i_buffer -= i_skip;

	//p_pes->i_dts = 100 * p_pes->i_dts / 9;
	//p_pes->i_pts = 100 * p_pes->i_pts / 9; /* converted to usec */
	p_pes->i_flags = BLOCK_FLAG_TYPE_AUDIO;
	if (header[3] == 0xe0) {
		p_pes->i_flags = BLOCK_FLAG_TYPE_I;
		int type = p_pes->p_buffer[4] & 0x1f;
		if (type == 1) {
			p_pes->i_flags = BLOCK_FLAG_TYPE_PB;
		} else {
			if (*p_header_len == -1) {
				if (type == 7) {
					struct frameperiod fp;
					struct resolution res;
					/* find NAL start for PPS */
					uint8_t * nal_start = find_NAL_start(p_pes->p_buffer + 5, p_pes->i_buffer - 5, 8);
					if (nal_start) {
						int len = nal_start - p_pes->p_buffer - 5;
						/* does not work for Zeus 3 (No VUI parameters present) */
						//parse_sps(p_pes->p_buffer + 5, len, &fp, &res);
						/* find NAL start for I frame */
						nal_start = find_NAL_start(nal_start + 5, p_pes->i_buffer - 5 - len - 5, 5);
						if (nal_start) {
							*p_header_len = nal_start - p_pes->p_buffer + 5;
						} else {
							return EGENERIC;
						}
					}
				}
			}
		}
	}
	//TRACE(_T("PTS:%I64d(%x)\n"), p_pes->i_pts, p_pes->i_flags);

	return SUCCESS;
}

int stream_peek( struct ps_stream *s, uint8_t *pBuf, int size )
{
	int64_t pos;
	size_t n;

	pos = ftell(s->fp);

	n = fread(pBuf, 1, size, s->fp);
	fseek(s->fp, pos, SEEK_SET);

	return n;
}

int stream_peek_from_buffer( struct ps_buffer *s, uint8_t *pBuf, size_t size )
{
	size_t n;

	n = s->pStart + s->size - s->pCurrent; // bytes left

	if (n > size) {
		n = size; // bytes to read
	}

	memcpy(pBuf, s->pCurrent, n);

	return n;
}

int64_t stream_tell( struct ps_stream *s)
{
	return ftell(s->fp);
}

int stream_seek( struct ps_stream *s, int64_t i_pos)
{
	return fseek(s->fp, i_pos, SEEK_SET);
}

int64_t stream_size( struct ps_stream *s)
{
	int64_t pos;

	if (s->end == 0) {
		pos = ftell(s->fp);
		fseek(s->fp, 0LL, SEEK_END);
		s->end = ftell(s->fp);
		fseek(s->fp, pos, SEEK_SET);	
	}
	return s->end;
}


int stream_read( struct ps_stream *s, uint8_t *pBuf, int size )
{
	int64_t pos;
	size_t n;

	if (pBuf == NULL) {
		pos = ftell(s->fp);
		if (s->end == 0) {
			fseek(s->fp, 0LL, SEEK_END);
			s->end = ftell(s->fp);
			fseek(s->fp, pos, SEEK_SET);			
		}
		fseek(s->fp, size, SEEK_CUR);
		if ((int)(s->end - pos) < size) {
			return (int)(s->end - pos);
		}
		return size;
	}

	n = fread(pBuf, 1, size, s->fp);

	return n;
}

int stream_read_from_buffer( struct ps_buffer *s, uint8_t *pBuf, size_t size )
{
	size_t n;

	n = s->pStart + s->size - s->pCurrent; // bytes left
	if (n > size) {
		n = size; // bytes to read
	}

	if (pBuf == NULL) {
		s->pCurrent += n;
		return n;
	}

	memcpy(pBuf, s->pCurrent, n);
	s->pCurrent += n;

	return n;
}

/* ps_pkt_resynch: resynch on a system starcode
*  It doesn't skip more than 512 bytes
*  -1 -> error, 0 -> not synch, 1 -> ok
*/
int ps_pkt_resynch( struct ps_stream *s, uint32_t *pi_code )
{
	uint8_t peek[512], *p_peek;
	int     i_peek;
	int     i_skip;

	if( stream_peek( s, peek, 4 ) < 4 )
	{
		return -1;
	}
	if( peek[0] == 0 && peek[1] == 0 && peek[2] == 1 &&
		peek[3] >= 0xb9 )
	{
		*pi_code = 0x100 | peek[3];
		return 1;
	}

	if( ( i_peek = stream_peek( s, peek, 512 ) ) < 4 )
	{
		return -1;
	}
	i_skip = 0;

	p_peek = peek;
	for( ;; )
	{
		if( i_peek < 4 )
		{
			break;
		}
		if( p_peek[0] == 0 && p_peek[1] == 0 && p_peek[2] == 1 &&
			p_peek[3] >= 0xb9 )
		{
			*pi_code = 0x100 | p_peek[3];
			return stream_read( s, NULL, i_skip ) == i_skip ? 1 : -1;
		}

		p_peek++;
		i_peek--;
		i_skip++;
	}
	return stream_read( s, NULL, i_skip ) == i_skip ? 0 : -1;
}

/* ps_pkt_resynch_from_buffer: resynch on a system starcode
*  It doesn't skip more than 512 bytes
*  -1 -> error, 0 -> not synch, 1 and above -> ok
*/
int ps_pkt_resynch_from_buffer( struct ps_buffer *s, uint32_t *pi_code )
{
	uint8_t peek[512], *p_peek;
	int     i_peek;
	int     i_skip;

	if( stream_peek_from_buffer( s, peek, 4 ) < 4 )
	{
		return -1;
	}
	if( peek[0] == 0 && peek[1] == 0 && peek[2] == 1 &&
		peek[3] >= 0xb9 )
	{
		*pi_code = 0x100 | peek[3];
		return 1;
	}

	if( ( i_peek = stream_peek_from_buffer( s, peek, 512 ) ) < 4 )
	{
		return -1;
	}
	i_skip = 0;

	p_peek = peek;
	for( ;; )
	{
		if( i_peek < 4 )
		{
			break;
		}
		if( p_peek[0] == 0 && p_peek[1] == 0 && p_peek[2] == 1 &&
			p_peek[3] >= 0xb9 )
		{
			*pi_code = 0x100 | p_peek[3];
			return stream_read_from_buffer( s, NULL, i_skip ) == i_skip ? 1 : -1;
		}

		p_peek++;
		i_peek--;
		i_skip++;
	}
	return stream_read_from_buffer( s, NULL, i_skip ) == i_skip ? 0 : -1;
}

/* return the id of a PES (should be valid) */
int ps_pkt_id( BLOCK_T *p_pkt )
{
	if( p_pkt->p_buffer[3] == 0xbd &&
		p_pkt->i_buffer >= 9 &&
		p_pkt->i_buffer >= 9 + p_pkt->p_buffer[8] )
	{
		return 0xbd00 | p_pkt->p_buffer[9+p_pkt->p_buffer[8]];
	}
	return p_pkt->p_buffer[3];
}

/* return the size of the next packet
* XXX you need to give him at least 14 bytes (and it need to start as a
* valid packet) */
int ps_pkt_size( uint8_t *p, int i_peek )
{
	if( p[3] == 0xb9 && i_peek >= 4 )
	{
		return 4;
	}
	else if( p[3] == 0xba )
	{
		if( (p[4] >> 6) == 0x01 && i_peek >= 14 )
		{
			return 14 + (p[13]&0x07);
		}
		else if( (p[4] >> 4) == 0x02 && i_peek >= 12 )
		{
			return 12;
		}
		return -1;
	}
	else if( i_peek >= 6 )
	{
		return 6 + ((p[4]<<8) | p[5] );
	}
	return -1;
}

CMpegPs::CMpegPs()
{
  m_b_mpeg2 = true;;
  m_i_psm_version = 1;
  m_i_dts_delay = 0;
  if( m_b_mpeg2 ) {
    uint32_t i, j, k;
    
    for( i = 0; i < 256; i++ ) {
      k = 0;
      for( j = (i << 24) | 0x800000; j != 0x80000000; j <<= 1 )
	k = (k << 1) ^ (((k ^ j) & 0x80000000) ? 0x04c11db7 : 0);
      
      m_crc32_table[i] = k;
    }
  }
  Init();
}

CMpegPs::~CMpegPs()
{
  if (m_pBlockSave) {
  		block_Release(m_pBlockSave);
  }
}

void CMpegPs::Init()
{
	m_bLostSync = false;
	m_iLength = -1;
	m_iTimeTrack = -1;
	memset(&m_stream, 0, sizeof(struct ps_stream));
	memset(&m_buffer, 0, sizeof(struct ps_buffer));
	m_iScr = -1;
	m_iMuxRate = 0;
	m_iCurrentPts = 0;
	m_iFlag = 0;
	ps_track_init( m_tk );
	m_pCryptTable = NULL;
	m_encryptSize = 0;
	m_pBlockSave = NULL;
	m_i_header_len = -1;
#ifdef COPY_PS
	m_bufSize = m_sizeof_m_buf = 0;
#endif
}
void CMpegPs::SetStream(FILE *fp)
{
	m_stream.fp = fp;
	m_stream.end = 0;
}

void CMpegPs::SetBuffer(uint8_t * pBuf, int size)
{
	m_buffer.pStart = m_buffer.pCurrent = pBuf;
	m_buffer.size = size;
}

int CMpegPs::PktResynch(uint32_t *i_code)
{
	if (m_stream.fp) {
		return ps_pkt_resynch(&m_stream, i_code);
	} else if (m_buffer.pStart) {
		return ps_pkt_resynch_from_buffer(&m_buffer, i_code);
	}

	return -1;
}

int CMpegPs::Demux2(bool b_end, int64_t *found_ts)
{
  int i_ret, i_id;
  uint32_t i_code;
  BLOCK_T *p_pkt;
  struct osd_hdr osdheader;
  
  if (StreamPeek( (uint8_t *)&osdheader, 3 ) < 3) {
    return 0;
  }
  
  if ((osdheader.magic[0] == 'T') && (osdheader.magic[1] == 'X') && (osdheader.magic[2] == 'T')) {
    i_ret = StreamRead((uint8_t *)&osdheader, sizeof(struct osd_hdr));
    if (i_ret == sizeof(struct osd_hdr)) {	
      uint8_t * tmpbuf = (uint8_t *)malloc(osdheader.osd_len);
      StreamRead(tmpbuf, osdheader.osd_len);
      free(tmpbuf);
    }
  }

  i_ret = PktResynch(&i_code );
  if( i_ret < 0 )
    {
      return 0;
    }
  else if( i_ret == 0 )
    {
      if( !m_bLostSync )
	fprintf(stderr, "garbage at input, trying to resync...\n" );
      
      m_bLostSync = true;
      return 1;
    }
  
  if( m_bLostSync ) fprintf(stderr, "found sync code\n" );
  m_bLostSync = false;
  
  if( ( p_pkt = PktRead( i_code ) ) == NULL )
    {
      return 0;
    }
  
  if( (i_id = ps_pkt_id( p_pkt )) >= 0xc0 )
    {
      int tkidx = ((i_id) <= 0xff ? (i_id) - 0xc0 : ((i_id)&0xff) + (256 - 0xc0));
      ps_track_t *tk = &m_tk[tkidx];
      if( !ps_pkt_parse_pes( p_pkt, tk->i_skip, &m_i_header_len ) )
	{
	  if( b_end && p_pkt->i_pts > tk->i_last_pts )
	    {
	      tk->i_last_pts = p_pkt->i_pts;
	    }
	  else if ( tk->i_first_pts == -1 )
	    {
	      tk->i_first_pts = p_pkt->i_pts;
	      if (found_ts) *found_ts = p_pkt->i_pts;
	    }
	}
    }
#ifndef COPY_PS
  block_Release( p_pkt );
#endif
  
  return 1;
}

#ifdef COPY_PS
int CMpegPs::copyToBuffer(psblock_t *p_pkt)
{
  if (!p_pkt || !p_pkt->i_buf)
    return 1;
  if (m_sizeof_m_buf - m_bufSize < p_pkt->i_buf)
    return 1;
  m_bufSize += p_pkt->i_buf;

  return 0;
}
#endif

static int convert_frametype(uint32_t flag)
{
  switch (flag) {
  case BLOCK_FLAG_TYPE_I:
    return FRAMETYPE_KEYVIDEO;
  case BLOCK_FLAG_TYPE_PB:
    return FRAMETYPE_VIDEO;
  case BLOCK_FLAG_TYPE_AUDIO:
    return FRAMETYPE_AUDIO;
  default:
    return FRAMETYPE_UNKNOWN;
  }

  return FRAMETYPE_UNKNOWN;
}

#ifdef COPY_PS
int CMpegPs::Demux(int *frametype, int64_t *ts)
#else
int CMpegPs::Demux(block_t **pp_block)
#endif
{
  int i_ret, i_id, i_mux_rate;
  uint32_t i_code;
  BLOCK_T *p_pkt;
  struct osd_hdr osdheader;
  
  if (StreamPeek( (uint8_t *)&osdheader, 3 ) < 3) {
    return -1;
  }
  
  if ((osdheader.magic[0] == 'T') && (osdheader.magic[1] == 'X') && (osdheader.magic[2] == 'T')) {
    i_ret = StreamRead((uint8_t *)&osdheader, sizeof(struct osd_hdr));
    if (i_ret == sizeof(struct osd_hdr)) {	
      if (osdheader.osd_len > 0) {
	if ((m_sizeof_m_buf - m_bufSize) >= 
	    ((int)sizeof(struct osd_hdr) + osdheader.osd_len)) {
	  memcpy(m_buf + m_bufSize, &osdheader, sizeof(struct osd_hdr)); 
	  m_bufSize += sizeof(struct osd_hdr);
	  StreamRead(m_buf + m_bufSize, osdheader.osd_len);
	  m_bufSize += osdheader.osd_len;
	}
      }
    }
  }
  
#ifndef COPY_PS
  *pp_block = NULL;
#endif
  
  i_ret = PktResynch( &i_code );
  if( i_ret < 0 )
    {
      return -1;
    }
  else if( i_ret == 0 )
    {
      if( !m_bLostSync )
	fprintf(stderr, "garbage at input, trying to resync...\n" );

      m_bLostSync = true;
      return 1;
    }

  if( m_bLostSync ) fprintf(stderr, "found sync code\n" );
  m_bLostSync = false;

  if( (m_iLength < 0) && (m_stream.fp) )
    FindLength();

  if( ( p_pkt = PktRead( i_code ) ) == NULL )
    {
      return 0;
    }
  
  switch( i_code )
    {
    case 0x1b9:
#ifdef COPY_PS
      copyToBuffer(p_pkt);
#else
      block_Release( p_pkt );
#endif
      break;

    case 0x1ba:
#ifdef COPY_PS
      copyToBuffer(p_pkt);
#endif
      if( !ps_pkt_parse_pack( p_pkt, &m_iScr, &i_mux_rate ) )
	{
	  if( !m_bHavePack ) m_bHavePack = true;
	  if( i_mux_rate > 0 ) m_iMuxRate = i_mux_rate;
	}
#ifndef COPY_PS
      block_Release( p_pkt );
#endif
      break;

    case 0x1bb:
      /* we don't get this */
#ifdef COPY_PS
      copyToBuffer(p_pkt);
#else
      block_Release( p_pkt );
#endif
      break;

    case 0x1bc:
      m_iFlag |= GOT_PSM;
#ifdef COPY_PS
      copyToBuffer(p_pkt);
#else
      block_Release( p_pkt );
#endif
      break;

    default:
      if( (i_id = ps_pkt_id( p_pkt )) >= 0xc0 )
	{
	  ps_track_t *tk = &m_tk[PS_ID_TO_TK(i_id)];
	  
	  if( !tk->b_seen )
	    {
	      tk->b_seen = true;
	    }

	  m_iScr = -1;

	  if( tk->b_seen &&
	      !ps_pkt_parse_pes( p_pkt, tk->i_skip, &m_i_header_len ) )
	    {
	      if( (int64_t)p_pkt->i_pts > m_iCurrentPts )
		{
		  m_iCurrentPts = (int64_t)p_pkt->i_pts;
		}
#ifdef TEST614
	      if (i_id == 0xc0) {
		*pp_block = p_pkt;
	      } else {
		*pp_block = copyVideoPES(p_pkt);
		block_Release( p_pkt );
	      }
#else
	      /* do not release buffer here, pass the buffer to avoid memcpy */
#if 0
	      /* decrypt only video frames */
	      if (m_pCryptTable) {
		p_pkt->i_header = 0; /* default for audio: no NAL start code */
		if (p_pkt->i_flags == BLOCK_FLAG_TYPE_I) {
		  p_pkt->i_header = (m_i_header_len == -1) ? 107 : m_i_header_len;
		} else if (p_pkt->i_flags == BLOCK_FLAG_TYPE_PB) {
		  p_pkt->i_header = 5;
		}
		uint8_t * pbyte = p_pkt->p_buffer + p_pkt->i_header;
		int size = p_pkt->i_buffer - p_pkt->i_header;					
		if (size > m_encryptSize) {
		  size = m_encryptSize;
		}
		if (size < 0) size = 0;
		RC4_block_crypt(pbyte, size, 0, m_pCryptTable, CRYPT_TABLE_SIZE);	
	      }
#endif
#ifdef COPY_PS
	      copyToBuffer(p_pkt);
	      *frametype = convert_frametype(p_pkt->i_flags);
	      *ts = p_pkt->i_pts;
#else
	      *pp_block = p_pkt;
#endif	
#endif
	    }
	  else
	    {
#ifndef COPY_PS
	      block_Release( p_pkt );
#endif
	    }
	}
      else
	{
#ifndef COPY_PS
	  block_Release( p_pkt );
#endif
	}
      break;
    }

  return 1;
}

int64_t CMpegPs::FindLength()
{
	int64_t i_current_pos = -1, i_size = 0, i_end = 0, len = 0;
	int i;

	if( m_iLength == -1 ) /* First time */
	{
		m_iLength = 0;
		/* Check beginning */
		i = 0;
		i_current_pos = stream_tell( &m_stream );
		while( i < 40 && Demux2( false ) > 0 ) i++;

		/* Check end */
		i_size = stream_size( &m_stream );
		i_end = max1( 0, min1( 200000, i_size ) );
		stream_seek( &m_stream, i_size - i_end );

		while( Demux2( true ) > 0 );
		if( i_current_pos >= 0 ) stream_seek( &m_stream, i_current_pos );
	}

	for( i = 0; i < PS_TK_COUNT; i++ )
	{
		ps_track_t *tk = &m_tk[i];
		if( tk->i_first_pts >= 0 && tk->i_last_pts > 0 ) {
			if( tk->i_last_pts > tk->i_first_pts )
			{
				int64_t i_length = (int64_t)tk->i_last_pts - tk->i_first_pts;
				if( i_length > m_iLength )
				{
					len = m_iLength = i_length;
					m_iTimeTrack = i;
					int64_t len_in_usec = 100 * len / 9; /* converted to usec */

					fprintf(stderr, "we found a length of: %lld@90KHz, %lld usec\n", m_iLength,len_in_usec);
				}
			}
		}
	}

	return len;
}

#ifdef COPY_PS
int CMpegPs::GetFrame(char *buf, int sizeof_buf, int *frametype, int64_t *ts)
{
  int ret, retry = 50;

  m_sizeof_m_buf = sizeof_buf; 
  m_buf = (uint8_t *)buf;
  m_bufSize = 0;
  *ts = 0;
  *frametype = FRAMETYPE_UNKNOWN;
  m_iFlag = 0;

  while (--retry > 0) {
    ret = Demux(frametype, ts);
    if (ret < 0) {
      //fprintf(stderr, "Demux error\n");
      break;
    }
    if (*frametype != FRAMETYPE_UNKNOWN) {
      ret = m_bufSize;
      m_bufSize = 0;
      return ret;
    }
  }

  return 0;
}
#else
block_t *CMpegPs::GetFrame()
{
	int ret, retry = 50;
	block_t *pBlock;

	m_iFlag = 0;

	while (--retry > 0) {
		ret = Demux(&pBlock);
		if (ret < 0) {
		  fprintf(stderr, "Demux error\n");
			break;
		}
		if (pBlock) {
			return pBlock;
		}
	}

	return NULL;
}
#endif

int64_t CMpegPs::FindFirstTimeStamp()
{
  int64_t i_current_pos = -1;
  int i;
  int64_t found_ts;
  uint8_t buf[500*1024]; /* temporary buffer */
  m_buf = buf;
  m_sizeof_m_buf = sizeof(buf); 
  m_bufSize = 0;

  if( m_iLength != -1 ) { /* should be called first */
    return 0;
  }
  
  m_iLength = 0;
  found_ts = 0;
  
  /* Check beginning */
  i = 0;
  i_current_pos = stream_tell( &m_stream );    
  while (i < 40) {
    if (Demux2(false, &found_ts) <= 0) {
      break;
    }
    if (found_ts)
      break;
    i++;
  }
  
  if( i_current_pos >= 0 ) stream_seek( &m_stream, i_current_pos );
  
  return found_ts;
}

int CMpegPs::StreamPeek( uint8_t *pBuf, int size )
{
	if (m_stream.fp) {
		return stream_peek( &m_stream, pBuf, size );
	} else if (m_buffer.pStart) {
		return stream_peek_from_buffer( &m_buffer, pBuf, size );
	}
	return 0;
}

/* must be called after PsFindLength() */
int64_t CMpegPs::GetFirstTimeStamp()
{
	int i;
	int64_t ts = 0;

	for( i = 0; i < PS_TK_COUNT; i++ ) {
		ps_track_t *tk = &m_tk[i];
		if( tk->i_first_pts >= 0 && tk->i_last_pts > 0 ) {	
			if( tk->i_last_pts > tk->i_first_pts ) {
				if (ts == 0) {
					ts = tk->i_first_pts;	
				} else if (tk->i_first_pts < ts) {
					ts = tk->i_first_pts;	
				}
			}
		}
	}

	return ts;
}

int64_t CMpegPs::StreamSize()
{
	return stream_size(&m_stream);
}

BLOCK_T *CMpegPs::PktRead( uint32_t i_code )
{
	uint8_t * p_peek = NULL;
	int pbuf_size = 14;
	p_peek = (uint8_t *)malloc(pbuf_size);
	if (!p_peek)
		return NULL;

	int      i_peek = StreamPeek( p_peek, 14 );
	int      i_size = ps_pkt_size( p_peek, i_peek );

	if( i_size <= 6 && p_peek[3] > 0xba )
	{
		/* Special case, search the next start code */
		i_size = 6;
		for( ;; )
		{
			if (i_size + 1024 > pbuf_size) {
				p_peek = (uint8_t *)realloc(p_peek, i_size + 1024);
				pbuf_size = i_size + 1024;
			}
			i_peek = StreamPeek( p_peek, i_size + 1024 );
			if( i_peek <= i_size + 4 )
			{
				free(p_peek);
				return NULL;
			}
			while( i_size <= i_peek - 4 )
			{
				if( p_peek[i_size] == 0x00 && p_peek[i_size+1] == 0x00 &&
					p_peek[i_size+2] == 0x01 && p_peek[i_size+3] >= 0xb9 )
				{
					free(p_peek);
					return StreamBlock( i_size );
				}
				i_size++;
			}
		}
	}
	else
	{
		/* Normal case */
		free(p_peek);
		return StreamBlock( i_size );
	}

	free(p_peek);
	return NULL;
}

int CMpegPs::StreamRead(uint8_t *pBuf, int size)
{
  if (m_stream.fp) {
    return stream_read( &m_stream, pBuf, size ); 
  } else {
    return stream_read_from_buffer( &m_buffer, pBuf, size ); 
  }
}

BLOCK_T *CMpegPs::StreamBlock( int i_size )
{
	if ((m_stream.fp == NULL) && (m_buffer.pStart == NULL))
		return NULL;

	if( i_size <= 0 )
		return NULL;

#ifdef COPY_PS
	psblock_t *p_bk = psblock_New(&m_block, m_buf + m_bufSize, i_size);
#else
	block_t *p_bk = block_New( i_size );
#endif
	if( p_bk ) {
		if (m_stream.fp) {
			p_bk->i_buffer = stream_read( &m_stream, p_bk->p_buffer, i_size ); 
		} else {
			p_bk->i_buffer = stream_read_from_buffer( &m_buffer, p_bk->p_buffer, i_size ); 
		}
		if( p_bk->i_buffer > 0 ) {    
			return p_bk;
		}
	}

#ifndef COPY_PS
	if( p_bk ) block_Release( p_bk );
#endif
	return NULL;
}

void CMpegPs::SetEncrptTable(unsigned char * pCryptTable, int size)
{
	m_pCryptTable = pCryptTable;
	m_encryptSize = size;
}

static inline int PESHeader( uint8_t *p_hdr, mtime_t i_pts, mtime_t i_dts,
                             int i_es_size,
                             int i_stream_id, bool b_mpeg2,
                             bool b_data_alignment, int i_header_size )
{
    bits_buffer_t bits;
    int     i_extra = 0;
    int i_private_id = -1;
    int i_stream_id_extension = 0;

    bits_initwrite( &bits, 50, p_hdr );

    /* add start code */
    bits_write( &bits, 24, 0x01 );
    bits_write( &bits, 8, i_stream_id );
    switch( i_stream_id )
    {
        case PES_PROGRAM_STREAM_MAP:
        case PES_PADDING:
        case PES_PRIVATE_STREAM_2:
        case PES_ECM:
        case PES_EMM:
        case PES_PROGRAM_STREAM_DIRECTORY:
        case PES_DSMCC_STREAM:
        case PES_ITU_T_H222_1_TYPE_E_STREAM:
            /* add pes data size  */
            bits_write( &bits, 16, i_es_size );
            bits_align( &bits );
            return( bits.i_data );

        default:
            /* arg, a little more difficult */
            if( b_mpeg2 )
            {
                int i_pts_dts;
                bool b_pes_extension_flag = false;

                if( i_pts > 0 && i_dts > 0 )
                {
                    i_pts_dts = 0x03;
                    if ( !i_header_size ) i_header_size = 0xa;
                }
                else if( i_pts > 0 )
                {
                    i_pts_dts = 0x02;
                    if ( !i_header_size ) i_header_size = 0x5;
                }
                else
                {
                    i_pts_dts = 0x00;
                    if ( !i_header_size ) i_header_size = 0x0;
                }

                if( i_stream_id == PES_EXTENDED_STREAM_ID )
                {
                    b_pes_extension_flag = true;
                    i_header_size += 1 + 1;
                }

                if( b_pes_extension_flag )
                {
                    i_header_size += 1;
                }

                /* Unbounded streams are only allowed in TS (not PS) and only
                 * for some ES, eg. MPEG* Video ES or Dirac ES. */
                if( i_es_size > PES_PAYLOAD_SIZE_MAX )
                    bits_write( &bits, 16, 0 ); // size unbounded
                else
                    bits_write( &bits, 16, i_es_size + i_extra + 3
                                 + i_header_size ); // size
                bits_write( &bits, 2, 0x02 ); // mpeg2 id
                bits_write( &bits, 2, 0x00 ); // pes scrambling control
                bits_write( &bits, 1, 0x00 ); // pes priority
                bits_write( &bits, 1, b_data_alignment ); // data alignement indicator
                bits_write( &bits, 1, 0x00 ); // copyright
                bits_write( &bits, 1, 0x00 ); // original or copy

                bits_write( &bits, 2, i_pts_dts ); // pts_dts flags
                bits_write( &bits, 1, 0x00 ); // escr flags
                bits_write( &bits, 1, 0x00 ); // es rate flag
                bits_write( &bits, 1, 0x00 ); // dsm trick mode flag
                bits_write( &bits, 1, 0x00 ); // additional copy info flag
                bits_write( &bits, 1, 0x00 ); // pes crc flag
                bits_write( &bits, 1, b_pes_extension_flag );
                bits_write( &bits, 8, i_header_size );

                /* write pts */
                if( i_pts_dts & 0x02 )
                {
                    bits_write( &bits, 4, i_pts_dts ); // '0010' or '0011'
                    bits_write( &bits, 3, i_pts >> 30 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_pts >> 15 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_pts );
                    bits_write( &bits, 1, 0x01 ); // marker
                    i_header_size -= 0x5;
                }
                /* write i_dts */
                if( i_pts_dts & 0x01 )
                {
                    bits_write( &bits, 4, 0x01 ); // '0001'
                    bits_write( &bits, 3, i_dts >> 30 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_dts >> 15 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_dts );
                    bits_write( &bits, 1, 0x01 ); // marker
                    i_header_size -= 0x5;
                }
                if( b_pes_extension_flag )
                {
                    bits_write( &bits, 1, 0x00 ); // PES_private_data_flag
                    bits_write( &bits, 1, 0x00 ); // pack_header_field_flag
                    bits_write( &bits, 1, 0x00 ); // program_packet_sequence_counter_flag
                    bits_write( &bits, 1, 0x00 ); // P-STD_buffer_flag
                    bits_write( &bits, 3, 0x07 ); // reserved
                    bits_write( &bits, 1, 0x01 ); // PES_extension_flag_2
                    /* skipping unsupported parts: */
                    /*   PES_private_data */
                    /*   pack_header */
                    /*   program_packet_sequence_counter */
                    /*   P-STD_buffer_flag */
                    if( i_stream_id == PES_EXTENDED_STREAM_ID )
                    {
                        /* PES_extension_2 */
                        bits_write( &bits, 1, 0x01 ); // marker
                        bits_write( &bits, 7, 0x01 ); // PES_extension_field_length
                        bits_write( &bits, 1, 0x01 ); // stream_id_extension_flag
                        bits_write( &bits, 7, i_stream_id_extension );
                        i_header_size -= 0x2;
                    }
                    i_header_size -= 0x1;
                }
                while ( i_header_size )
                {
                    bits_write( &bits, 8, 0xff );
                    i_header_size--;
                }
            }
            else /* MPEG1 */
            {
                int i_pts_dts;

                if( i_pts > 0 && i_dts > 0)
                {
                    bits_write( &bits, 16, i_es_size + i_extra + 10 /* + stuffing */ );
                    i_pts_dts = 0x03;
                }
                else if( i_pts > 0 )
                {
                    bits_write( &bits, 16, i_es_size + i_extra + 5 /* + stuffing */ );
                    i_pts_dts = 0x02;
                }
                else
                {
                    bits_write( &bits, 16, i_es_size + i_extra + 1 /* + stuffing */);
                    i_pts_dts = 0x00;
                }

                /* FIXME: Now should be stuffing */

                /* No STD_buffer_scale and STD_buffer_size */

                /* write pts */
                if( i_pts_dts & 0x02 )
                {
                    bits_write( &bits, 4, i_pts_dts ); // '0010' or '0011'
                    bits_write( &bits, 3, i_pts >> 30 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_pts >> 15 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_pts );
                    bits_write( &bits, 1, 0x01 ); // marker
                }
                /* write i_dts */
                if( i_pts_dts & 0x01 )
                {
                    bits_write( &bits, 4, 0x01 ); // '0001'
                    bits_write( &bits, 3, i_dts >> 30 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_dts >> 15 );
                    bits_write( &bits, 1, 0x01 ); // marker
                    bits_write( &bits, 15, i_dts );
                    bits_write( &bits, 1, 0x01 ); // marker
                }
                if( !i_pts_dts )
                {
                    bits_write( &bits, 8, 0x0F );
                }

            }

            /* now should be stuffing */
            /* and then pes data */

            bits_align( &bits );
            if( i_stream_id == PES_PRIVATE_STREAM_1 && i_private_id != -1 )
            {
                bits_write( &bits, 8, i_private_id );
                if( ( i_private_id&0xf0 ) == 0x80 )
                {
                    bits_write( &bits, 24, 0 ); // ac3
                }
            }
            bits_align( &bits );
            return( bits.i_data );
    }
}

int CMpegPs::Mux(int frame_type, int i_es_size, int64_t i_dts,
		 int audio_enabled)
{
  int len = 0;
  int64_t i_pts_in_90khz = i_dts / 100 * 9;

  if (frame_type == FRAMETYPE_KEYVIDEO) {
    len = MuxWritePackHeader( i_dts );
    len += MuxWritePSM(m_ps_hdr + len, audio_enabled);
    len += PESHeader((uint8_t *)m_ps_hdr + len, i_pts_in_90khz, 0,
		     i_es_size, 0xe0, 1, 0, 0);
  } else if (frame_type == FRAMETYPE_VIDEO) {
    len = MuxWritePackHeader( i_dts );
    len += PESHeader((uint8_t *)m_ps_hdr + len, i_pts_in_90khz, 0,
		     i_es_size, 0xe0, 1, 0, 0);
  } else {
    len += PESHeader((uint8_t *)m_ps_hdr + len, i_pts_in_90khz, 0,
		     i_es_size, 0xc0, 1, 0, 0);
  }

  return len;
}

int CMpegPs::MuxWritePackHeader( int64_t i_dts /* usec */ )
{
  bits_buffer_t bits;
  int64_t i_scr;
  int i_mux_rate;

  i_scr = (i_dts - m_i_dts_delay) * 9 / 100 ; 

    bits_initwrite( &bits, 14, m_ps_hdr );
    bits_write( &bits, 32, 0x01ba );

    /* The spec specifies that the mux rate must be rounded upwards */
    i_mux_rate = (100000/* dummy rate */ + 8 * 50 - 1 ) / (8 * 50);

    if( m_b_mpeg2 )
    {
        bits_write( &bits, 2, 0x01 );
    }
    else
    {
        bits_write( &bits, 4, 0x02 );
    }

    bits_write( &bits, 3, ( i_scr >> 30 )&0x07 );
    bits_write( &bits, 1,  1 ); // marker
    bits_write( &bits, 15, ( i_scr >> 15 )&0x7fff );
    bits_write( &bits, 1,  1 ); // marker
    bits_write( &bits, 15, i_scr&0x7fff );
    bits_write( &bits, 1,  1 ); // marker

    if( m_b_mpeg2 )
    {
        bits_write( &bits, 9,  0 ); // src extension
    }
    bits_write( &bits, 1,  1 );     // marker

    bits_write( &bits, 22, i_mux_rate);
    bits_write( &bits, 1,  1 );     // marker

    if( m_b_mpeg2 )
    {
        bits_write( &bits, 1,  1 );     // marker
        bits_write( &bits, 5,  0x1f );  // reserved
        bits_write( &bits, 3,  0 );     // stuffing bytes
    }

    return m_b_mpeg2 ? 14: 12;
}

int CMpegPs::MuxWritePSM( char *p_buffer, int audio_enabled)
{
    bits_buffer_t bits;
    int i, i_psm_size = 16, i_es_map_size = 0;

    i_es_map_size = 4;
    if (audio_enabled)
      i_es_map_size = 8;

    i_psm_size += i_es_map_size;

    bits_initwrite( &bits, i_psm_size, p_buffer );
    bits_write( &bits, 32, 0x01bc );
    bits_write( &bits, 16, i_psm_size - 6 );
    bits_write( &bits, 1, 1 ); /* current_next_indicator */
    bits_write( &bits, 2, 0xF ); /* reserved */
    bits_write( &bits, 5, m_i_psm_version );
    bits_write( &bits, 7, 0xFF ); /* reserved */
    bits_write( &bits, 1, 1 ); /* marker */

    bits_write( &bits, 16, 0 ); /* program_stream_info_length */
    /* empty */

    bits_write( &bits, 16, i_es_map_size ); /* elementary_stream_map_length */

    /* video */
    bits_write( &bits, 8, 0x1b ); /* stream_type: H.264 */
    bits_write( &bits, 8, 0xe0 ); /* elementary_stream_id */

    if (audio_enabled) {
      bits_write( &bits, 8, 0x03 ); /* stream_type: ISO/IEC 11172 Audio, not used anyway */
      bits_write( &bits, 8, 0xc0 ); /* elementary_stream_id */
    }

    bits_write( &bits, 16, 0 ); /* elementary_stream_info_length */

    /* CRC32 */
    {
        uint32_t i_crc = 0xffffffff;
        for( i = 0; i < i_psm_size; i++ )
        i_crc = (i_crc << 8) ^
            m_crc32_table[((i_crc >> 24) ^ p_buffer[i]) & 0xff];

        bits_write( &bits, 32, i_crc );
    }

      return i_psm_size;
}

